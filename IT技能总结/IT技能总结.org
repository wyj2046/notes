#+TITLE: IT技能总结
#+AUTHOR: wyj
#+EMAIL: rs@whu.edu.cn
#+KEYWORDS: emacs, notes
#+OPTIONS: H:2 toc:t ^:{}
#+STYLE: <link rel="stylesheet" type="text/css" href="./style/style.css" />


* 语言
** C
*** 预处理
*** static
*** 内存
**** 堆 
**** 栈
*** volatile
** C++
*** const
*** virtual
** JAVA

** Shell Script
*** sed
*** awk
** Emacs Lisp
* 数据结构
** 链表
** 二项堆
** Hash表
** Bloom Filter
** 并查集
** 字典树
** 二叉搜索树
** AVL树
** 红黑树
** B-树 B+树
** ? Skew/Leftist Heap
** ? Splay
* 算法
** 二分搜索
** 排序
*** 冒泡
*** 选择
*** 插入
*** 希尔
*** 堆
*** 归并
*** 快排
*** 计数排序
*** 基排序
*** 桶排序
** 搜索
*** 深度优先
*** 广度优先
** 动态规划
** Dijkstra/Floyd/Bellman-Ford最短路径算法
** 网络流
* 操作系统
** 进程
#+BEGIN_VERSE
执行中的程序
#+END_VERSE
** 线程
#+BEGIN_VERSE
是操作系统能够进行运算调度的最小单位，它被包涵在进程中，是进程的实际运作单位
同一进程中的多线程将共享该进程中的全部系统资源，如虚拟地址空间，文件描述符和信号处理
但同一进程中的多线程有各自的调用栈，自己的寄存器环境，自己的线程本地存储
#+END_VERSE
** 线程安全
#+BEGIN_VERSE
多线程运行结果和单线程运行结果一样，而且其他的变量值也和预期一样
线程安全问题都是由全局变量及静态变量引起的
#+END_VERSE
** 进程与线程的区别
#+BEGIN_VERSE
1. 它们是操作系统管理资源的不同方式。
2. 进程有独立的地址空间，一个进程崩溃后，在保护模式下不会对其他进程产生影响
3. 线程只是一个进程中的不同执行路径。线程有自己的堆栈和局部变量，但线程之间没有单独的地址空间，一个线程死掉就等于整个进程死掉
4. 所以多进程的程序比多线程的程序 *健壮* ，但在进程切换时，耗费资源较大， *效率* 要差些
#+END_VERSE
** 用户态 内核态
#+BEGIN_VERSE
内核态就是拥有资源多的状态，也称为特权态
用户态也称为非特权态，此种状态下访问的资源将受到限制
为了区分不同程序的不同权利，发明了用户态和内核态
#+END_VERSE
** fiber
Windows中把这种用户级线程叫做Fiber
** race condition
#+BEGIN_VERSE
多个线程争相执行同一段代码或访问同一资源的现象
#+END_VERSE
** mutex(互斥信号量)
** 管程
#+BEGIN_VERSE
信号量存在程序编写困难或程序效率低下的问题，将信号量的这些组织工作交给一个专门的构造来管，程序员就解脱了，管程出场
管程就是一组子程序、变量和数据结构的组合
管程使用两种同步机制：锁用来互斥，条件变量用来控制执行的顺序
条件变量：线程可以在上面等待的东西，另外一个线程可以通过发送信号将在条件变量上等待的线程叫醒
#+END_VERSE
** 死锁的4个必要条件(缺一不可)
   - 资源有限(这个条件也称为资源互斥条件。即资源不能共享，在一个时候只能由一个线程使用)
   - 持有等待：一个线程在请求新的资源时，其已获得的资源并不释放，而是继续持有
   - 不能抢占：如果一个资源可以被抢占，则死锁也不会发生
   - 循环等待(最后一个条件)：如果你等我、我等你，大家这样都等着对方，就死锁
** 时间片
#+BEGIN_VERSE
分时操作系统给每个正在运行的进程微观上 *一段CPU时间*
#+END_VERSE
** 虚拟内存
#+BEGIN_VERSE
虚拟内存的中心思想是将物理主存扩大到磁盘上，即将磁盘空间看作是主存空间的一部分
对程序地址所在位置(缓存、主存、磁盘)的判断是内存管理系统的一个中心功能
虚拟内存除了让程序员感觉到内存 _容量_ 大大增加之外，还让程序员感觉到内存 _速度_ 也加快了
x86下，虚拟内存地址空间是4G。Linux下内核态1G用户态3G。Win一般是2G/2G
#+END_VERSE
** MMU
#+BEGIN_VERSE
MMU对虚拟地址的翻译只是对页面号的翻译，即将虚拟页面号翻译成物理页面号。
而对于偏移值，则不进行任何操作。这是因为虚拟页表和物理页表大小完全一样，虚拟页面里的偏移值和物理页面里的偏移值完全一样，因此无需翻译
MMU通过查页表完成翻译
#+END_VERSE

** swap(交换)
#+BEGIN_VERSE
当一个程序所占空间不够时，我们将其倒出来倒到磁盘上，再加载到更大的一片内存空间去。
这种将程序倒出到磁盘上，再加载回内存的管理方式就称为交换
#+END_VERSE
** 内存是分页的
#+BEGIN_VERSE
页：将虚拟内存与物理内存分成大小一样的部分
按页进行内存分配，就可以克服外部碎片的问题
(外部碎片：散布在进程之间的闲置空间。因为从进程的粒度来看，这种碎片处于进程空间的外面)
分页系统的核心就是将虚拟内存空间和物理内存空间皆划分为大小相同的页面，如4KB、8KB、16KB等，并以页面做为内存空间的最小分配单位，
一个程序的一个页面可以存放在任意一个物理页面里
分页系统的核心是页面的翻译，即从虚拟页面到物理页面的映射，这个翻译过程由MMU(内存管理单元)完成
** 页表
#+BEGIN_VERSE
页表不光用来进行翻译，还用来进行页面的各种状态判断
页表的根本功能是提供从虚拟页面到物理页面的映射
页表的记录条数与虚拟页面数相同
页表是一个硬件数据结构
#+END_VERSE
** TLB(Translation lookaside buffer)
#+BEGIN_VERSE
页表缓冲，里面存放的是一些页表文件。
又称为快表技术，由于页表存储在主存储器中，查询页表所付出的代价很大，由此产生了TLB
#+END_VERSE
** 为什么要页面更换？
#+BEGIN_VERSE
如果访问的页面不在内存，则系统将产生缺页中断。缺页中断服务程序将负责把位于磁盘上的数据加载到物理内存来。
如果物理内存有空闲页面，那就直接使用空闲的页面。但 *如果物理内存已满* ，则需要挑选某个已经使用过的页面来进行替换
#+END_VERSE
** 页面更换算法
*** 公平算法
**** 随机算法
**** 先进先出算法
**** 第二次机会算法
#+BEGIN_VERSE
在使用FIFO更换一个页面时，检查页面最近是否被访问过。如果没有被访问过，则替换该页面。如果最近有被访问过，则不替换
#+END_VERSE
**** 时钟算法
#+BEGIN_VERSE
时钟算法的精髓也是第二次机会，只不过使用不同的数据结构，第二次机会使用的是链表，时钟使用的是索引
#+END_VERSE
*** 不公平算法
**** 最优更换算法
**** NRU算法(最近未使用Not Recently Used)
**** LRU算法(最近最少使用Least Recently Used)
**** 工作集算法
** mmap
#+BEGIN_VERSE
将文件或设备映射进内存，如此可以把对文件的操作转为对内存的操作，以此避免更多的lseek、read、write操作，这点对于大文件或者频繁访问的文件尤其收益
#+END_VERSE

* *nix
** 基本使用
** 编程
* 数据库

* 网络
** HTTP
** SSL
** DHCP
** TCP UDP
** Cookie
#+BEGIN_VERSE
Cookie是什么？
Cookie是一小段文本信息，伴随着用户请求和页面在Web服务器和浏览器之间传递。Cookie包含每次用户访问站点时Web应用程度都可以读取的信息。
为什么需要Cookie？
因为Http协议是无状态的，对于一个浏览器发出的多次请求，WEB服务器无法区分是不是来源于同一个浏览器。所以，需要额外的数据用于维护对话。
Cookie能做什么？
Cookie只是一段文本，所以它只能保存字符串。而且浏览器对它有大小限制。
Cookie的内容也是明文保存的，有些浏览器提供界面修改，所以，不适合保存重要的或者涉及隐私的内容。
Cookie的限制。
大多数浏览器支持最大为4096字节的Cookie。由于这限制了Cookie的大小，最好用Cookie来存储少量数据，或者存储用户ID之类的标识符。
#+END_VERSE
** SSL(安全套接层)
#+BEGIN_VERSE
SSL(Secure Sockets Layer)采用公开秘匙技术，保证两个应用间通信的保密性和可靠性，使客户与服务器应用之间的通信不被攻击者窃听。
优势：SSL协议的优势在于它是 *与应用层协议独立无关的* 。高层的应用层协议能透明的建立于SSL协议之上。
     SSL协议 *在应用层协议通信之前* 就已经完成加密算法、通信密匙的协商以及服务器认证工作。在此之后应用层协议所传送的数据都会被加密，从而保证通信的私密性
#+END_VERSE
** HTTPS
#+BEGIN_VERSE
超文本传输安全协议(Hypertext Transfer Protocol Secure)是HTTP和SSL/TLS的组合，用以提供加密通讯及对网络服务器身份的鉴定。
HTTPS的主要思想是在不安全的网络上创建一安全信道，并可在使用适当的加密套件和服务器证书可被验证且可被信任时，对窃听和中间人攻击提供合理的保护
#+END_VERSE
** HTTP GET
#+BEGIN_VERSE
向特定的资源发出请求。使用GET获得请求仅能用来获取数据而不应该有其他影响。
#+END_VERSE
** HTTP POST
#+BEGIN_VERSE
向指定资源提交数据进行处理请求(例如提交表单或者上传文件)。数据被包含在请求体中。
#+END_VERSE
** DHCP
#+BEGIN_VERSE
动态主机配置协议(Dynamic Host Configuration Protocol)是一个局域网的网络协议，使用UDP协议工作，主要有两个用途：
- 给内部网络或网络服务供应商 *自动分配IP地址给用户*
- 给内部网络管理员作为对 *所有电脑作中央管理的手段*
#+END_VERSE
** SSH
#+BEGIN_VERSE
SSH为Secure Shell的缩写，为创建在应用层和传输层基础上的安全协议。
通过SSH可以对所有传输的数据进行加密，也能够防止DNS欺骗和IP欺骗
SSH另一优点为其传输的数据是经过压缩的，所以可以加快传输的速度
#+END_VERSE
** DNS
#+BEGIN_VERSE
域名系统(Domain Name System)可以将域名与IP地址相互映射为一个分布式数据库，能够使人更方便的访问互联网，而不用去记IP地址
#+END_VERSE
** TCP与UDP的区别
*** TCP
#+BEGIN_VERSE
TCP(Transmission Control Protocol)是一种面向连接的协议，这意味着它通过握手来建立端对端的通信。一旦一个连接建立起来，用户数据就可以双向传递
- 可靠的
TCP使消息acknowledgment, retransimission and timeout, 多种方法来分发消息。如果丢包了，则服务器将会要求重新发送丢包部分。TCP保证要么不丢失数据，做不到的话就关闭连接
- 有序的
TCP保证发送的消息与接收的消息顺序一致
- 重量级
TCP在发送任何用户数据之前需要3个包来设置socket连接
#+END_VERSE
- 流模式
数据被作为字节流来读取
*** UDP
#+BEGIN_VERSE
UDP(User Datagram Protocol)是一种简单的基于消息的无连接协议。这意味着它不用设置精确的端对端连接。连接是单向的(这句话不太确定，可能改为发送消息时是单向的更合适？)，并且没有验证是否有接收到
- 不可靠的
当一个消息发送时，它并不知道自己是否能到目的地，UDP也没有acknowledgment, retransmission, timeout的概念
- 无序的
消息到达的顺序是不可预测的
- 轻量级
没有消息顺序，没有跟踪连接
- 数据报(Datagrams)模式
数据包被单独发送同时仅仅在它们到达时作为整体检查
- 没有阻塞控制
#+END_VERSE
#+begin_example
UDP对于Web服务器和email服务是一个较差的选择
UDP对于允许丢帧的声音和视频流是较好的选择
#+end_example
** TCP是怎么保证数据完整性的
#+BEGIN_VERSE
TCP协议使用 _重新发送与正向ACK_ 来保证数据传输的可靠性。发送方等待一段时间，如果没有收到其发送的数据包的ACK确认信息，发送方就要重新发送
TCP会对收到的包做校验和，如果校验不正确地话可以让发送端重发
#+END_VERSE
** 三次握手
*** 第一次握手：建立连接时，客户端A发送SYN包(SYN=j)到服务器B，并进入SYN_SEND状态，等待服务器B确认
   A想B请求连接
*** 第二次握手：服务器B收到SYN包，必须确认客户A的SYN(ACK=j+1)，同时自己也发送一个SYN包(SYN=k)，即SYN+ACK包，此时服务器进入SYN_RECV状态
   B回应A：好的，你来吧
*** 第三次握手：客户端A收到服务器B的SYN+ACK包，向服务器B发送确认包ACK(ACK=k+1)，此包发送完毕，客户端A和服务器B进入ESTABLISHED状态，完成三次握手
   A回应B：好的，我来也
** 四次分手
*** 客户端A发送一个FIN，用来关闭客户A到服务器B的数据传送
   A对B说：我传完了
*** 服务器B收到这个FIN，它发回一个ACK，确认序号为收到的序号加1。和SYN一样，一个FIN将占用一个序号
   B回应A：好的
*** 服务器B关闭与客户端A的连接，发送一个FIN给客户端A
   B对A说：我传完了too
*** 客户端A发回ACK报文确认，并将确认序号设置为收到序号加1
   A回应B：好的，我走了
** 为什么建立连接协议是三次握手，而关闭连接却是四次握手呢？
#+BEGIN_VERSE
这是因为服务端的LISTEN状态下的SOCKET当收到SYN报文的连接请求后，它可以 *把ACK和SYN(ACK起应答作用，而SYN起同步作用)放在一个报文里来发送* 。
但关闭连接时，当收到双方的FIN报文通知时， *它仅仅表示对方没有数据发送给你了* ；
*但未必你所有的数据都全部发送给对方了* ，所以你可能未必会马上关闭SOCKET，
也即你可能还需要发送一些数据给对方之后，再发送FIN报文给对方来表示你同意现在可以关闭连接了，所以它这里的 *ACK报文和FIN报文多数情况下都是分开发送的*
#+END_VERSE

* 硬件
** CPU

** 内存

** 磁盘

** RAID
* UML

* 设计模式
** 单例模式
** 工厂模式
* 版本控制
** Git

** SVN
* 正则表达式

* 机器学习
