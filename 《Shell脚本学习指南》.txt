2.4
当一个文件开头的两个字符是#!时，UNIX内核会扫描该行其余的部分，看是否存在可用来执行程序的解释器的完整路径
脚本是否具有可移植性取决于是否有完整的路径名称
Shell在后台执行其前面的命令，意味着Shell不用等到该命令完成，就可以继续执行下一个命令

2.5
变量赋值的方式：先写变量名称，紧接着=字符，最后是新值，（亮点）中间完全没有任何空格。当所赋值内容含空格时，需加引号
以<改变标准输入
以>改变标准输出
以>>附加到文件
/dev/null就是位桶，传送到此文件的数据都会被系统丢掉。即当程序将数据写到此文件时，会认为它已成功完成写入数据的操作，但实际上什么事都没做
/dev/tty，当程序打开此文件时，UNIX会自动将它重定向到一个终端再与程序结合，这在程序必须读取人工输入时(例如密码)特别有用
如果你要编写自己的脚本，最好准备自己的bin目录来存放它们，并且让Shell能够自动找到它们。这不难，只要建立自己的bin目录，并将它们加入$PATH中的列表即可：
cd
mkdir bin
mv nusers(脚本名) bin
PATH=$PATH:$HOME/bin
要让修改永久生效，在.profile文件中加这句PATH=$PATH:$HOME/bin

3.2
方括号表达式中，所有元字符都会失去其特殊含义
grep加上-v选项可以用来显示所有不匹配于模式的行
grep -v ^$ 过滤掉文件里的空行

3.3
awk pattern {action}
awk的输入、输出分隔字符用法是分开的，这点与其他工具程序不同
记得在print的参数间用逗点隔开！否则，awk将连接相邻的所有值

4.2
sort -u的消除操作时依据匹配的键值，而非匹配的记录
uniq常用于管道中，用来删除已使用sort排序完成的重复记录

6.1
$# 提供传递到Shell脚本或函数的参数总数
$*或$@ 一次表示所有的命令行参数
"$*" 将所有命令行参数视为单个字符串，等同于"$1 $2 ..."
"$@" 将所有命令行参数视为单独的个体，也就是单独字符串，等同于"$1" "$2" ...

6.2
程序的退出状态：每一条命令，不管是内置的、Shell函数，还是外部的，当它退出时，都会返回一个小的整数值给引用它的程序
以惯例来说，退出状态为0表示”成功“(注意：与C/C++习惯完全相反)
test用来测试文件属性、比较字符串及比较数字
-a和-o是test运算符，而&&和||是Shell运算符
POSIX建议少用-a和-o运算符

10.4
find不同于ls的3个地方：
1.它没有隐藏文件的概念
2.find不排序文件名
3.当find处理的是目录时，它会自动递归深入目录结构
