#+TITLE: 《深入浅出SQL》
#+AUTHOR: wyj
#+EMAIL: rs@whu.edu.cn
#+KEYWORDS: emacs, notes
#+OPTIONS: H:2 toc:t ^:{}
#+STARTUP: indent
#+STYLE: <link rel="stylesheet" type="text/css" href="./style/style.css" />
* chp1
** 复习要点
+ CREATE DATABASE 数据库名
+ USE DATABASE
+ CREATE TABLE 表名
+ DESC 表名
+ DROP TABLE 表名
+ INSERT INTO 表名 (列名1, 列名2, ...) VALUES (值1, 值2, ...)
* chp2
** 没有蠢问题
SQL中能用双引号代替单引号吗？
不能，因为SQL语句日后会搭配其他编程语言(如PHP)。在编程语言中使用""表示"从这里开始是SQL语句"，这样单引号才会被视为SQL语句的一部分，而不是其他编程语言的一部分
** 再谈LIKE
LIKE喜欢和通配符在一起，第一个通配符是%，它是 *任意数量* 的位置字符串的替身
LIKE喜欢的第二个通配符是下划线_，它是 *一个* 未知字符的替身
** 偷偷告诉你……BETWEEN更好
BETWEEN等于使用<=加>=，但不等于<加>
** 更多NOT
NOT可以和BETWEEN和LIKE一起使用。重点是记得 *NOT一定要紧接在WHERE后面*
当NOT和AND或OR一起使用时，则要直接接在AND或OR的后面
* chp3
看起来好像有些你不想删除的数据被删除了。也许应该先SELECT一下，看看哪些数据会被某些WHERE子句删除
** UPDATE的规则
- 使用UPDATE，你可以改变单一列或所有列的值。在SET子句中加入更多column = value组，其间以逗号分隔
- UPDTAE可用于更新单一行或多行，一切都交给WHERE子句决定
* chp4
** 达成1NF的半路上
1) 每个数据行必须包含具有原子性的值
2) 每个数据行必须由独一无二的识别项，人称主键
** 主键规则
主键：是表中的某个列，它可以 *让每一条记录称为唯一* 的
- 主键不可以为NULL
- 插入新纪录时必须指定主键值
- 主键必须简洁
- 主键值不可以被修改
* chp5
** 没有蠢问题
- 创建表后你就无法真正地改变列的顺序了。最多只能在指定位置添加新列，然后删除旧列，但这样会丢失旧列中的所有数据
- 磁盘里存储数据的顺序并不重要
** 没有蠢问题
每个表中只有一列可以加上AUTO_INCREMENT，该列必须为整数类型而且不能包含NULL
* chp7
我们需要把不符合原子性的列移入新的表
对数据库内的 _数据描述_ (列和表)，以及任何相关对象和各种 _连接_ 方式的描述就称为 _SCHEMA_ ，模式
为表创建图表可以协助我们 _分别看待_ 表的 _设计_ 与其中的 _数据_
** 外键二三事
- 外键使用的主键也被称为父键(parent key)
- 主键所在的表被称为父表(parent table)
- 外键能用于确认一张表中的行与另一张表中的行相对应
- 外键的值可以是NULL，即使主键值不可为NULL
- 外键值不需唯一――事实上，外键通常都没有唯一性
外键为NULL，表示在父表中没有相符的主键
** 外键约束
插入外键列的值必须已经存在于父表的来源列中，这是 _引用完整性_

** p308
外键约束能确保引用完整性
** p315
此时，在两个多对多的表之间需要一个中间桥梁来存储所有woman_id和shoe_id，从而把关系简化为一对多。
这个中间桥梁就是所谓的junction table(连接表)，用它来存储两个相关表的主键
** p316
遇到多对多关系的时候，一定要创建中间表
** p322
组合键就是由多个数据列构成的主键，组合各列后形成具有唯一性的键
** p323
当某列的数据必须随着另一列的数据的改变而改变时，表示第一列 _函数依赖_ 于第二列
** p324
T.x -> T.y
可以解释成“在关系表T中，y列函数依赖于x列”。基本上，从右读到左就是解读依赖性的方式
** p325
部分函数依赖是指非主键的某列依赖于组合主键的某个部分(但不是完全依赖于组合主键)
在超级英雄表中，initials列对name列的依赖正是部分依赖性的例子。
如果超级英雄改名了，那么缩写列也要跟着修改，但英雄的能力如果变了，缩写并不需要跟着修改
** p326
如果改变任何非键列可能造成其他列的改变，即为传递依赖
传递函数依赖：任何非键列与另一个非键列有关联
** p331
第二范式，又称2NF：
规则一：先符合1NF
规则二：没有部分函数依赖性
** p336
任何具有人工主键且没有组合主键的表都符合2NF
第三范式，又称3NF：
规则一：符合2NF
规则二：没有传递函数依赖性
** p359
交叉联接是内联接的一种。
内联接基本上就是通过查询中的条件移除了某些结果数据行后的交叉联接。
** p363
INNER JOIN利用条件式里的比较运算符结合两张表
** p368
自然联接只有在联接的列在两张表中的名称都相同时才会有用
* chp9
** p386
子查询，是被另一个查询包围的查询，也可称为内层查询
** p399
如果子查询可以 _独立运行_ 且 _不会引用_ 外层查询的任何结果，即称为 _非关联子查询_
** p403
_非关联子查询_ 使用IN或NOT IN来检查子查询返回的值是否为集合的成员之一
* chp10
** p419
_LEFT OUTER JOIN_ 会匹配左表中的每一行及右表中符合条件的行
** p421
内联接与外联接的差别：外联接一定会提供数据行，无论该行能否在另一个表中找出相应匹配的行。
左外联接的结果集中的NULL表示右表中 _没有_ 找到与左表相符的记录
** p432
_自引用外键_ 是个出于其他目的而用于 _同一张表_ 的主键
** p435
自联接能把单一表当成两张具有完全相同的信息的表来进行查询
** p438
UNION只能接受一个ORDER BY且必须位于语句末端
* chp11
** p477
当数据库的使用者不只一人时，CHECK CONSTRAINT与视图均有助于维护控制权
** p482
*事务* 是一群可完成一组工作的SQL语句
在事务过程中，如果 _所有_ 步骤无法不受干扰地完成，则不该完成 _任何_ 单一步骤
** p483
*** ACID:Automicity
    原子性。事务里的每一个步骤都必须完成，否则只能都不完成。不能只执行部分事务
*** ACID:Consistency
    一致性。事务完成后应该维持数据库的一致性。
*** ACID:Isolation
    隔离性。表示每次事务都会看到具有一致性的数据库，无论其他事务有什么行动。
*** ACID:Durability
    持久性。事务完成后，数据库需要正确地存储数据并保护数据免受断电或其他威胁的伤害。
** p484
在你COMMIT之前数据库都不会发生任何改变
* chp12
** p499
使用GRANT语句可以控制用户对表和列可执行的操作
** p504
GRANT TO
REVOKE FROM
